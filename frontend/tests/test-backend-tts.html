<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åç«¯ TTS æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
        input, select { padding: 5px; margin: 5px; }
        .log { max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>ğŸ”Š åç«¯ TTS æµ‹è¯•</h1>
    
    <div class="test-section">
        <h3>ğŸ¯ æ–‡æœ¬è½¬è¯­éŸ³æµ‹è¯•</h3>
        <input type="text" id="text-input" value="ä½ å¥½ï¼Œè¿™æ˜¯ä¸€ä¸ªåç«¯ TTS æµ‹è¯•ã€‚" style="width: 400px;">
        <select id="voice-select">
            <option value="zh-CN-XiaoxiaoNeural">æ™“æ™“ (å¥³å£°)</option>
            <option value="zh-CN-YunxiNeural">äº‘å¸Œ (ç”·å£°)</option>
            <option value="zh-CN-YunyangNeural">äº‘æ‰¬ (ç”·å£°)</option>
        </select>
        <button onclick="testTextToSpeech()">æ–‡æœ¬è½¬è¯­éŸ³</button>
        <div id="text-result"></div>
        <audio id="text-audio" controls style="margin-top: 10px;"></audio>
    </div>
    
    <div class="test-section">
        <h3>ğŸ“ SSML è½¬è¯­éŸ³æµ‹è¯•</h3>
        <textarea id="ssml-input" rows="4" style="width: 400px;"><speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="zh-CN">
  <voice name="zh-CN-XiaoxiaoNeural">
    è¿™æ˜¯ SSML æ ¼å¼çš„æµ‹è¯•ã€‚
  </voice>
</speak></textarea>
        <button onclick="testSSMLToSpeech()">SSML è½¬è¯­éŸ³</button>
        <div id="ssml-result"></div>
        <audio id="ssml-audio" controls style="margin-top: 10px;"></audio>
    </div>
    
    <div class="test-section">
        <h3>ğŸ” è°ƒè¯•æ—¥å¿—</h3>
        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        <div id="debug-log" class="log"></div>
    </div>

    <script type="module">
        // æ¨¡æ‹Ÿ BackendAzureTTS æ¨¡å—
        const API_BASE_URL = 'http://localhost:3000';
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('debug-log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'success';
            logDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function logResult(elementId, message, isError = false) {
            const element = document.getElementById(elementId);
            const className = isError ? 'error' : 'success';
            element.innerHTML = `<div class="${className}"><pre>${message}</pre></div>`;
        }
        
        async function synthesizeSpeech(content, voice = 'zh-CN-XiaoxiaoNeural', isSSML = false) {
            log(`ğŸ”Š å¼€å§‹è¯­éŸ³åˆæˆ: ${isSSML ? 'SSML' : 'æ–‡æœ¬'}, è¯­éŸ³: ${voice}`);
            
            try {
                // å¤„ç† SSML æ ¼å¼
                let processedContent = content;
                if (isSSML) {
                    // ä¸å¯é çš„ SSML ç›´æ¥é‡æ„ä¸ºæ ‡å‡†æ ¼å¼
                    processedContent = content.replace(/pitch="0st"/g, 'pitch="+0st"');

                    const inner = content
                        .replace(/<speak[\s\S]*?>/, '')
                        .replace(/<\/speak>/, '')
                        .trim();

                    const hasVoice = /<voice[\s>]/i.test(inner);
                    let processed = inner;
                    if (hasVoice) {
                        const m = inner.match(/<voice[^>]*name=["']([^"']+)["']/i);
                        const detected = m?.[1];
                        if (detected && detected !== voice) {
                            log(`âš ï¸ LLM returned voice "${detected}" which differs from selected "${voice}"`, 'warning');
                        }
                    } else {
                        processed = `<voice name="${voice}">${inner}</voice>`;
                    }
                    const wrapped = processed;
                    processedContent = `<speak version="1.0" xml:lang="zh-CN" xmlns="http://www.w3.org/2001/10/synthesis" xmlns:mstts="http://www.w3.org/2001/mstts">${wrapped}</speak>`;
                } else {
                    // çº¯æ–‡æœ¬ï¼ŒåŒ…è£…ä¸ºç®€å• SSML
                    processedContent = `<speak version="1.0" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="zh-CN">
  <voice name="${voice}">
    ${content}
  </voice>
</speak>`;
                }

                log(`ğŸ“¡ å‘é€è¯·æ±‚åˆ°: ${API_BASE_URL}/api/azure-tts`);
                log(`ğŸ“ å¤„ç†åçš„å†…å®¹: ${processedContent.slice(0, 200)}...`);
                
                const response = await fetch(`${API_BASE_URL}/api/azure-tts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        ssml: processedContent, 
                        voice 
                    }),
                });

                log(`ğŸ“¥ æ”¶åˆ°å“åº”: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    log(`âŒ è¯­éŸ³åˆæˆå¤±è´¥: ${errorData.error || response.statusText}`, 'error');
                    throw new Error(`Speech synthesis failed: ${errorData.error || response.statusText}`);
                }

                const blob = await response.blob();
                log(`âœ… è¯­éŸ³åˆæˆæˆåŠŸ: ${(blob.size / 1024).toFixed(2)} KB, ç±»å‹: ${blob.type}`);
                
                return blob;
            } catch (error) {
                log(`âŒ è¯­éŸ³åˆæˆè¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function testTextToSpeech() {
            const text = document.getElementById('text-input').value;
            const voice = document.getElementById('voice-select').value;
            
            log(`ğŸ¯ å¼€å§‹æ–‡æœ¬è½¬è¯­éŸ³: "${text}"`);
            
            try {
                const audioBlob = await synthesizeSpeech(text, voice, false);
                const audioUrl = URL.createObjectURL(audioBlob);
                document.getElementById('text-audio').src = audioUrl;
                logResult('text-result', `âœ… æˆåŠŸ!\néŸ³é¢‘å¤§å°: ${(audioBlob.size / 1024).toFixed(2)} KB\néŸ³é¢‘ç±»å‹: ${audioBlob.type}`);
            } catch (error) {
                logResult('text-result', `âŒ å¤±è´¥: ${error.message}`, true);
            }
        }
        
        async function testSSMLToSpeech() {
            const ssml = document.getElementById('ssml-input').value;
            const voice = document.getElementById('voice-select').value;
            
            log(`ğŸ“ å¼€å§‹ SSML è½¬è¯­éŸ³`);
            
            try {
                const audioBlob = await synthesizeSpeech(ssml, voice, true);
                const audioUrl = URL.createObjectURL(audioBlob);
                document.getElementById('ssml-audio').src = audioUrl;
                logResult('ssml-result', `âœ… æˆåŠŸ!\néŸ³é¢‘å¤§å°: ${(audioBlob.size / 1024).toFixed(2)} KB\néŸ³é¢‘ç±»å‹: ${audioBlob.type}`);
            } catch (error) {
                logResult('ssml-result', `âŒ å¤±è´¥: ${error.message}`, true);
            }
        }
        
        function clearLog() {
            document.getElementById('debug-log').innerHTML = '';
        }
        
        // æš´éœ²åˆ°å…¨å±€
        window.testTextToSpeech = testTextToSpeech;
        window.testSSMLToSpeech = testSSMLToSpeech;
        window.clearLog = clearLog;
        
        // é¡µé¢åŠ è½½æ—¶è®°å½•
        log('ğŸš€ åç«¯ TTS æµ‹è¯•é¡µé¢å·²åŠ è½½');
        log(`ğŸ“‹ API_BASE_URL: ${API_BASE_URL}`);
    </script>
</body>
</html> 
