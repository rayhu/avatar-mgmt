<template>
  <div class="animate-page">
    <h1>{{ t('animate.title') }}</h1>



    <!-- Ê®°ÂûãÈÄâÊã© -->
    <div class="model-selector">
      <h3>{{ t('modelManagement.modelSelection') }}</h3>
      <div v-if="!selectedModel" class="model-list">
        <div
          v-for="model in readyModels"
          :key="model.id"
          class="model-card"
          @click="selectModel(model)"
        >
          <div class="model-preview">
            <ModelCard :preview-url="model.previewUrl" />
          </div>
          <div class="model-info">
            <h4>{{ model.name }}</h4>
          </div>
        </div>
      </div>
      <div v-else class="selected-model">
        <div class="model-preview">
          <ModelCard :preview-url="selectedModel.previewUrl" />
        </div>
        <div class="model-info">
          <h4>{{ selectedModel.name }}</h4>
          <button class="control-btn" @click="selectedModel = null">
            {{ t('modelManagement.changeModel') }}
          </button>
        </div>
      </div>
    </div>

    <!-- <div class="viewer-container">
      <ModelViewer
        ref="modelViewer"
        :model-url="selectedModel?.url || '/models/default.glb'"
        :auto-rotate="true"
        :show-controls="true"
      />
    </div> -->

    <!-- Êó∂Èó¥ËΩ¥ÁºñËæëÂô® -->
    <div class="timeline-editor">
      <h3>{{ t('animate.timeline.title') }}</h3>
      <div class="timeline-container">
        <div class="timeline-header">
          <div class="track-label">{{ t('animate.timeline.time') }}</div>
          <div class="timeline-ruler">
            <!-- Ê°åÈù¢Á´ØÔºöÊòæÁ§∫ÊâÄÊúâÂàªÂ∫¶ -->
            <div
              v-for="i in timeMarkers.all"
              :key="`desktop-${i}`"
              class="time-marker desktop-marker"
              :style="{ left: `${(i - 1) * 3.33}%` }"
            >
              {{ i - 1 }}s
            </div>
            <!-- ÁßªÂä®Á´ØÔºöÂè™ÊòæÁ§∫‰∏ªË¶ÅÂàªÂ∫¶ -->
            <div
              v-for="i in timeMarkers.mobile"
              :key="`mobile-${i}`"
              class="time-marker mobile-marker"
              :style="{ left: `${(i - 1) * 3.33}%` }"
            >
              {{ i - 1 }}s
            </div>
          </div>
        </div>
        <div class="timeline-tracks">
          <div class="track">
            <div class="track-label">{{ t('animate.timeline.action') }}</div>
            <div class="track-content" @click="onTrackClick('action', $event)">
              <div
                v-for="keyframe in actionKeyframes"
                :key="keyframe.id"
                class="keyframe action-keyframe"
                :style="{ left: `${keyframe.time * 3.33}%` }"
                @click.stop="selectKeyframe(keyframe)"
                @mousedown="startDrag(keyframe, $event)"
              >
                {{ t(getActionDisplayName(keyframe.action || '')) }}
              </div>
            </div>
          </div>
          <div class="track">
            <div class="track-label">{{ t('animate.timeline.emotion') }}</div>
            <div class="track-content" @click="onTrackClick('emotion', $event)">
              <div
                v-for="keyframe in emotionKeyframes"
                :key="keyframe.id"
                class="keyframe emotion-keyframe"
                :style="{ left: `${keyframe.time * 3.33}%` }"
                @click.stop="selectKeyframe(keyframe)"
                @mousedown="startDrag(keyframe, $event)"
              >
                {{ t(getEmotionDisplayName(keyframe.emotion || '')) }}
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="timeline-controls">
        <button class="control-btn" @click="() => addActionKeyframe()">
          {{ t('animate.timeline.addAction') }}
        </button>
        <button class="control-btn" @click="() => addEmotionKeyframe()">
          {{ t('animate.timeline.addEmotion') }}
        </button>
        <button class="control-btn danger" @click="clearTimeline">
          {{ t('animate.timeline.clear') }}
        </button>
      </div>
    </div>

    <!-- ÂÖ≥ÈîÆÂ∏ßÁºñËæëÂô® -->
    <div v-if="selectedKeyframe" class="keyframe-editor">
      <h4>{{ t('animate.timeline.editKeyframe') }}</h4>
      <div class="editor-content">
        <div class="form-group">
          <label>{{ t('animate.timeline.time') }}</label>
          <input
            min="0"
            max="30"
            step="0.1"
            class="w-20 px-2 py-1 border rounded"
            type="number"
            :value="selectedKeyframe.time"
            @input="handleTimeInput"
          />
        </div>
        <div v-if="selectedKeyframe.type === 'action'" class="form-group">
          <label>{{ t('animate.timeline.action') }}</label>
          <select
            class="form-control"
            :value="selectedKeyframe.action"
            @change="handleActionSelect"
          >
            <option v-for="action in actions" :key="action" :value="action">
              {{ t(getActionDisplayName(action)) }}
            </option>
          </select>
        </div>
        <div v-if="selectedKeyframe.type === 'emotion'" class="form-group">
          <label>{{ t('animate.timeline.emotion') }}</label>
          <select
            class="form-control"
            :value="selectedKeyframe.emotion"
            @change="handleEmotionSelect"
          >
            <option v-for="emotion in emotions" :key="emotion" :value="emotion">
              {{ t(getEmotionDisplayName(emotion)) }}
            </option>
          </select>
        </div>
        <button class="delete-btn" @click="deleteKeyframe(selectedKeyframe)">
          {{ t('animate.timeline.delete') }}
        </button>
      </div>
    </div>

    <div class="animate-content">
      <div class="form-section">
        <div class="form-group">
          <label>{{ t('animate.text') }}</label>
          <textarea
            v-model="text"
            :placeholder="t('animate.textPlaceholder')"
            maxlength="180"
            :disabled="animationProcessing"
          ></textarea>
          <div class="char-count" :class="{ 'near-limit': charCount > 150 }">
            {{ charCount }}/180
          </div>
          <button class="control-btn" @click="onGenerateSSML">
            {{ t('animate.timeline.generateSSML') }}
          </button>
          <button class="control-btn danger" @click="onClearSSML" style="margin-left: 8px">
            {{ t('animate.timeline.clearEmotionTags') }}
          </button>

          <!-- SSML ÁºñËæëÂô® -->
          <textarea v-model="ssml" rows="8" class="ssml-textarea" />

          <!-- ËØ≠Èü≥ÈÄâÊã© -->
          <div class="form-group">
            <label>{{ t('animate.voice') }}</label>
            <select v-model="selectedVoice" class="form-control">
              <option
                v-for="voice in filteredVoices"
                :key="voice.name"
                :value="voice.name"
                :title="voice.styles ? voice.styles.join(', ') : ''"
              >
                {{ voice.label
                }}{{ voice.styles && voice.styles.length ? ' (' + voice.styles.length + ')' : '' }}
              </option>
            </select>
          </div>
        </div>
        <button class="generate-btn" :disabled="animationProcessing || !text.trim()" @click="() => { debugCurrentState(); onAnimate(); }">
          <span v-if="animationProcessing" class="loading-spinner"></span>
          <span v-else>{{ t('animate.submit') }}</span>
        </button>
        <!-- Ë∞ÉËØïÊåâÈíÆ -->
        <button class="control-btn" @click="debugCurrentState" style="margin-top: 8px; width: 100%;">
          üîç Ë∞ÉËØïÁä∂ÊÄÅÊ£ÄÊü•
        </button>
      </div>

      <div class="preview-section">
        <ModelViewer
          ref="modelViewer"
          :model-url="selectedModel?.url"
          :emotion="currentEmotion"
          :action="currentAction"
        />
        <audio ref="audioPlayer" controls :src="audioUrl"></audio>
        <!-- ËÉåÊôØÂõæÁâáÊéßÂà∂ -->
        <div class="background-controls">
          <input
            ref="imageInput"
            type="file"
            accept="image/*"
            @change="handleImageUpload"
            class="image-input"
            :disabled="animationProcessing"
          />
          <button 
            class="control-btn secondary" 
            @click="() => imageInput?.click()"
            :disabled="animationProcessing"
          >
            üñºÔ∏è {{ t('animate.selectImage') }}
          </button>
          <button 
            v-if="backgroundImage"
            class="control-btn danger" 
            @click="clearBackgroundImage"
            :disabled="animationProcessing"
          >
            üóëÔ∏è {{ t('animate.clearImage') }}
          </button>
        </div>
        
        <!-- ËÉåÊôØÊéßÂà∂Èù¢Êùø -->
        <div v-if="backgroundImage" class="background-control-panel">
          <h4>üé® ËÉåÊôØÊéßÂà∂</h4>
          
          <!-- Ë∑ùÁ¶ªÊéßÂà∂ -->
          <div class="control-group">
            <label class="control-label">
              üìè Ë∑ùÁ¶ª: {{ (backgroundDistance || 0).toFixed(1) }}
            </label>
            <div class="control-row">
              <input
                type="range"
                min="-10"
                max="-0.5"
                step="0.1"
                v-model="backgroundDistance"
                @input="adjustBackgroundDistance"
                class="distance-slider"
                :disabled="animationProcessing"
              />
              <div class="preset-buttons">
                <button 
                  v-for="(preset, index) in presetDistances"
                  :key="preset.value"
                  @click="setBackgroundDistance(preset.value)"
                  :class="{ active: Math.abs(backgroundDistance - preset.value) < 0.1 }"
                  class="preset-btn"
                  :title="`Âø´Êç∑ÈîÆ: ${index + 1}`"
                >
                  {{ preset.icon }} {{ preset.label }}
                </button>
              </div>
            </div>
          </div>
          
          <!-- ‰ΩçÁΩÆÂÅèÁßªÊéßÂà∂ -->
          <div class="control-group">
            <label class="control-label">üìç ‰ΩçÁΩÆÂÅèÁßª</label>
            <div class="offset-controls">
              <div class="offset-item">
                <span>X: {{ (backgroundOffset?.x || 0).toFixed(1) }}</span>
                <div class="offset-buttons">
                  <button @click="adjustOffset('x', -offsetStep)" :disabled="animationProcessing" title="Ctrl+‚Üê">‚Üê</button>
                  <button @click="adjustOffset('x', offsetStep)" :disabled="animationProcessing" title="Ctrl+‚Üí">‚Üí</button>
                </div>
              </div>
              <div class="offset-item">
                <span>Y: {{ (backgroundOffset?.y || 0).toFixed(1) }}</span>
                <div class="offset-buttons">
                  <button @click="adjustOffset('y', -offsetStep)" :disabled="animationProcessing" title="Ctrl+‚Üë">‚Üë</button>
                  <button @click="adjustOffset('y', offsetStep)" :disabled="animationProcessing" title="Ctrl+‚Üì">‚Üì</button>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Áº©ÊîæÊéßÂà∂ -->
          <div class="control-group">
            <label class="control-label">üîç Áº©Êîæ: {{ (backgroundScale || 1).toFixed(2) }}</label>
            <div class="scale-controls">
              <button @click="adjustScale(-scaleStep)" :disabled="animationProcessing" title="Ctrl+-">-</button>
              <input
                type="range"
                min="0.5"
                max="2.0"
                step="0.1"
                v-model="backgroundScale"
                @input="adjustBackgroundScale"
                class="scale-slider"
                :disabled="animationProcessing"
              />
              <button @click="adjustScale(scaleStep)" :disabled="animationProcessing" title="Ctrl+=">+</button>
            </div>
          </div>
          
          <!-- ÈáçÁΩÆÊåâÈíÆ -->
          <div class="control-group">
            <button 
              class="reset-btn" 
              @click="resetBackgroundSettings"
              :disabled="animationProcessing"
              title="Âø´Êç∑ÈîÆ: R"
            >
              üîÑ ÈáçÁΩÆËÆæÁΩÆ
            </button>
          </div>
          
          <!-- Âø´Êç∑ÈîÆÊèêÁ§∫ -->
          <div class="shortcut-tips">
            <small>
              üí° Âø´Êç∑ÈîÆ: Ctrl+ÊñπÂêëÈîÆ(‰ΩçÁΩÆ) | Ctrl+/- (Áº©Êîæ) | 1-4(È¢ÑËÆæË∑ùÁ¶ª) | R(ÈáçÁΩÆ)
            </small>
          </div>
        </div>
        
        <!-- ËÉåÊôØÂõæÁâáÈ¢ÑËßà -->
        <div v-if="backgroundImage" class="background-preview">
          <img :src="backgroundImage" :alt="t('animate.backgroundPreview')" />
          <span class="background-name">{{ backgroundImageName }}</span>
        </div>

        <div class="preview-controls">
          <button
            v-if="!isRecording"
            class="control-btn"
            :disabled="animationProcessing || !audioUrl"
            @click="() => startRecording(modelViewer, audioPlayer, audioUrl, startTimelineAnimation, syncVisemeWithAudio)"
          >
            {{ t('animate.record') }}
          </button>
          <button v-else class="control-btn danger" @click="stopRecording">
            {{ t('animate.stopRecording') }}
          </button>
          <button v-if="recordedVideoUrl" class="control-btn" @click="downloadVideo">
            {{ t('animate.download') }}
          </button>
          <button 
            v-if="recordedVideoUrl || isRecording" 
            class="control-btn secondary" 
            @click="resetRecordingState"
            title="ÈáçÁΩÆÂΩïÂà∂Áä∂ÊÄÅ"
          >
            üîÑ ÈáçÁΩÆÂΩïÂà∂
          </button>
          <button 
            class="control-btn outline" 
            @click="checkRecordingState"
            title="Ê£ÄÊü•ÂΩïÂà∂Áä∂ÊÄÅÔºàË∞ÉËØïÁî®Ôºâ"
          >
            üîç Áä∂ÊÄÅÊ£ÄÊü•
          </button>
          <div v-if="!audioUrl" class="recording-tip">
            {{ t('animate.recordingTip') }}
          </div>
        </div>
      </div>
    </div>

    <!-- ÊµãËØïÁî®ÔºöÂÖ∏ÂûãÊÉÖÁª™Á§∫‰æãË°®Ê†º -->
    <div class="sample-table">
      <h3>{{ t('animate.sampleSentences') }}</h3>
      <table>
        <thead>
          <tr>
            <th>{{ t('animate.emotion') }}</th>
            <th>{{ t('animate.text') }}</th>
          </tr>
        </thead>
        <tbody>
          <tr
            v-for="sample in samples"
            :key="sample.text"
            @click="applySample(sample.text)"
            class="sample-row"
          >
            <td>{{ sample.emotion }}</td>
            <td>{{ sample.text }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, onMounted, onUnmounted, computed, nextTick } from 'vue';
import { useI18n } from 'vue-i18n';
import type { Composer } from 'vue-i18n';
import ModelViewer from '@/components/ModelViewer.vue';
import ModelCard from '@/components/ModelCard.vue';
import {
  synthesizeSpeech as synthesizeSpeechFront,
  availableVoices,
  fetchVoices,
  type VoiceOption,
} from '@/api/azureTTS';
import { synthesizeSpeech as synthesizeSpeechBackend } from '@/api/BackendAzureTTS';
import { generateSSMLBackend } from '@/api/openaiBackend';
import { generateSSMLFront } from '@/api/openaiFrontend';
import { getActionAnimations, getEmotionAnimations } from '@/config/animations';

// ÂØºÂÖ•ÁªÑÂêàÂºèÂáΩÊï∞
import { useRecording } from '@/composables/useRecording';
import { useTimeline } from '@/composables/useTimeline';
import { useBackground } from '@/composables/useBackground';
import { useAnimation } from '@/composables/useAnimation';
import { useModelSelection } from '@/composables/useModelSelection';

interface Keyframe {
  id: string;
  time: number;
  type: 'action' | 'emotion';
  action?: string;
  emotion?: string;
}

const { t } = useI18n() as Composer;
const modelViewer = ref<InstanceType<typeof ModelViewer> | null>(null);
const text = ref('‰Ω†Â•ΩÔºåÊàëÊòØÊï∞Â≠ó‰∫∫ÔºåËøôÊòØ‰∏Ä‰∏™Â∞èÂ∞èÁöÑÊºîÁ§∫ÔºåÂ§ßÁ∫¶ÊåÅÁª≠5ÁßíÈíü„ÄÇ');

// ‰ΩøÁî®ÁªÑÂêàÂºèÂáΩÊï∞
const modelSelection = useModelSelection();
const { readyModels, selectedModel, currentEmotion, currentAction, fetchReadyModels } = modelSelection;

// ÂÖàÂàõÂª∫processingÁä∂ÊÄÅÁöÑrefÔºåÁ®çÂêé‰ºöË¢´useAnimationË¶ÜÁõñ
const isProcessing = ref(false);

const background = useBackground(modelViewer, isProcessing);
const {
  imageInput,
  backgroundImage,
  backgroundImageName,
  backgroundImageFile,
  backgroundDistance,
  backgroundOffset,
  backgroundScale,
  presetDistances,
  handleImageUpload,
  clearBackgroundImage,
  adjustBackgroundDistance,
  setBackgroundDistance,
  adjustBackgroundOffset,
  adjustOffset,
  adjustBackgroundScale,
  adjustScale,
  resetBackgroundSettings
} = background;

// ÊéßÂà∂Á≤æÂ∫¶Â∏∏Èáè
const distanceStep = 0.1;
const offsetStep = 0.5;
const scaleStep = 0.1;

// ‰ªéÈÖçÁΩÆÊñá‰ª∂Ëé∑ÂèñÂä®‰ΩúÂíåË°®ÊÉÖÊï∞ÊçÆ
const actionAnimations = getActionAnimations();
const emotionAnimations = getEmotionAnimations();

// ÊèêÂèñÂä®‰ΩúÂêçÁß∞Êï∞ÁªÑÔºàÁî®‰∫é‰∏ãÊãâÊ°ÜÔºâ
const actions = computed(() => 
  actionAnimations
    .filter(anim => anim.enabled)
    .map(anim => anim.actualName)
);

// ÊèêÂèñË°®ÊÉÖÂêçÁß∞Êï∞ÁªÑÔºàÁî®‰∫é‰∏ãÊãâÊ°ÜÔºâ
const emotions = computed(() => 
  emotionAnimations
    .filter(anim => anim.enabled)
    .map(anim => anim.actualName)
);

const charCount = computed({
  get: () => text.value.length,
  set: (value: number) => {
    if (value > 180) {
      text.value = text.value.slice(0, 180);
    }
  },
});

// Êó∂Èó¥Ê†áËÆ∞ÈÖçÁΩÆÂ∑≤ÁßªËá≥ useTimeline ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// Azure TTS voice list (reactive)
const voices = ref<VoiceOption[]>(availableVoices);

// Only display voices that start with zh-CN
const filteredVoices = computed(() => voices.value.filter((v) => v.name.startsWith('zh-CN')));

const selectedVoice = ref<string>(filteredVoices.value.find(v => v.name === 'zh-CN-YunxiaNeural')?.name || 'zh-CN-YunxiaNeural');

// ÂΩìÁî®Êà∑Êõ¥Êç¢ËØ≠Èü≥Êó∂ÔºåËá™Âä®Ê∏ÖÁ©∫Â∑≤ÁîüÊàêÁöÑ SSMLÔºåÈÅøÂÖçÂÜÖÂÆπ‰∏é voice ‰∏çÂåπÈÖç
watch(selectedVoice, () => {
  ssml.value = '';
});

// Try to fetch full voices list from Azure when component is mounted
async function loadVoices() {
  try {
    const remote = await fetchVoices();
    if (Array.isArray(remote) && remote.length) {
      // Keep only zh-CN voices for UI
      const zhVoices = remote.filter((v) => v.name.startsWith('zh-CN'));
      if (zhVoices.length) {
        voices.value = zhVoices;
      } else {
        voices.value = remote;
      }
      // Ensure selected voice exists
      if (!filteredVoices.value.find((v) => v.name === selectedVoice.value)) {
        selectedVoice.value = filteredVoices.value[0]?.name || selectedVoice.value;
      }
    }
  } catch (err) {
    console.warn('Unable to fetch voices list, fallback to static list.', err);
  }
}

onMounted(() => {
  loadVoices();
  fetchReadyModels();
  // ‰∏çÂÜç‰ΩøÁî®ËÄÅÁöÑ handleAudioPlay
  nextTick(() => {
    /* no-op */
  });
  
  // Ê∑ªÂä†ÈîÆÁõòÂø´Êç∑ÈîÆÁõëÂê¨
  document.addEventListener('keydown', handleKeyDown);
});

// ÈîÆÁõòÂø´Êç∑ÈîÆÊîØÊåÅ
function handleKeyDown(event: KeyboardEvent) {
  // Âè™Âú®ÊúâËÉåÊôØÂõæÁâáÊó∂ÂêØÁî®Âø´Êç∑ÈîÆ
  if (!backgroundImage.value) return;
  
  // Ê£ÄÊü•ÊòØÂê¶Âú®ËæìÂÖ•Ê°Ü‰∏≠ÔºåÂ¶ÇÊûúÊòØÂàô‰∏çÂ§ÑÁêÜÂø´Êç∑ÈîÆ
  const target = event.target as HTMLElement;
  if (target && (
    target.tagName === 'INPUT' || 
    target.tagName === 'TEXTAREA' || 
    target.tagName === 'SELECT' ||
    target.contentEditable === 'true'
  )) {
    return;
  }
  
  let handled = false;
  
  if (event.ctrlKey || event.metaKey) {
    switch (event.key) {
      case 'ArrowLeft':
        adjustOffset('x', -offsetStep);
        handled = true;
        break;
      case 'ArrowRight':
        adjustOffset('x', offsetStep);
        handled = true;
        break;
      case 'ArrowUp':
        adjustOffset('y', -offsetStep);
        handled = true;
        break;
      case 'ArrowDown':
        adjustOffset('y', offsetStep);
        handled = true;
        break;
      case '=':
      case '+':
        adjustScale(scaleStep);
        handled = true;
        break;
      case '-':
        adjustScale(-scaleStep);
        handled = true;
        break;
    }
  }
  
  // Êï∞Â≠óÈîÆÂø´ÈÄüËÆæÁΩÆÈ¢ÑËÆæË∑ùÁ¶ª
  if (event.key >= '1' && event.key <= '4') {
    const index = parseInt(event.key) - 1;
    if (presetDistances[index]) {
      setBackgroundDistance(presetDistances[index].value);
      handled = true;
    }
  }
  
  // RÈîÆÈáçÁΩÆËÆæÁΩÆ
  if (event.key === 'r' || event.key === 'R') {
    resetBackgroundSettings();
    handled = true;
  }
  
  // Âè™ÊúâÂú®Â§ÑÁêÜ‰∫ÜÂø´Êç∑ÈîÆÊó∂ÊâçÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫
  if (handled) {
    event.preventDefault();
    event.stopPropagation();
  }
}

// ÈÄâÊã©Ê®°Âûã - ‰ΩøÁî®ÁªÑÂêàÂºèÂáΩÊï∞
function selectModel(model: any) {
  modelSelection.selectModel(model);
}

// ÂÖ≥ÈîÆÂ∏ßÁºñËæëÂáΩÊï∞
function handleTimeInput(event: Event) {
  if (!selectedKeyframe.value) return;
  const target = event.target as HTMLInputElement;
  const newTime = parseFloat(target.value);
  selectedKeyframe.value.time = newTime;
  updateKeyframe(selectedKeyframe.value);
}

function handleActionSelect(event: Event) {
  if (!selectedKeyframe.value || selectedKeyframe.value.type !== 'action') return;
  const target = event.target as HTMLSelectElement;
  selectedKeyframe.value.action = target.value;
  updateKeyframe(selectedKeyframe.value);
}

function handleEmotionSelect(event: Event) {
  if (!selectedKeyframe.value || selectedKeyframe.value.type !== 'emotion') return;
  const target = event.target as HTMLSelectElement;
  selectedKeyframe.value.emotion = target.value;
  updateKeyframe(selectedKeyframe.value);
}

// SSML ÁîüÊàêÂíåÊ∏ÖÁêÜÂáΩÊï∞
async function onGenerateSSML() {
  if (!text.value.trim()) {
    alert(t('animate.textRequired'));
    return;
  }

  try {
    isGeneratingSSML.value = true;
    const result = await generateSSML(text.value, selectedVoice.value);
    ssml.value = result || text.value;
  } catch (error) {
    console.error('Failed to generate SSML:', error);
    alert(t('animate.ssmlGenerationError') || 'SSMLÁîüÊàêÂ§±Ë¥•');
  } finally {
    isGeneratingSSML.value = false;
  }
}

function onClearSSML() {
  ssml.value = '';
}

// Á§∫‰æãÂè•Â≠êÊï∞ÊçÆ
const samples = ref([
  { emotion: 'È´òÂÖ¥', text: '‰ªäÂ§©ÁúüÊòØÂ§™ÂºÄÂøÉ‰∫ÜÔºÅÈò≥ÂÖâÊòéÂ™öÔºåÂøÉÊÉÖÊ†ºÂ§ñÂ•Ω„ÄÇ' },
  { emotion: 'ÊÇ≤‰º§', text: 'Á¶ªÂà´ÊÄªÊòØËÆ©‰∫∫ÈöæËøáÔºå‰ΩÜÊàë‰ª¨Ë¶ÅÂ≠¶‰ºöÂùöÂº∫Èù¢ÂØπ„ÄÇ' },
  { emotion: 'ÊÑ§ÊÄí', text: 'ËøôÁßç‰∏çÂÖ¨Âπ≥ÁöÑÂæÖÈÅáËÆ©ÊàëÊÑüÂà∞ÈùûÂ∏∏ÊÑ§ÊÄíÔºÅ' },
  { emotion: 'ÊÉäËÆ∂', text: 'ÂìáÔºåËøô‰∏™ÁªìÊûúÁúüÊòØÂ§™Âá∫‰πéÊàëÁöÑÊÑèÊñô‰∫ÜÔºÅ' },
  { emotion: 'Âπ≥Èùô', text: '‰øùÊåÅÂÜÖÂøÉÁöÑÂπ≥ÈùôÔºåÊòØÈù¢ÂØπÂõ∞ÈöæÊúÄÂ•ΩÁöÑÊñπÂºè„ÄÇ' },
  { emotion: 'ÂÖ¥Â•ã', text: 'Áªà‰∫éË¶ÅÂÆûÁé∞ÊàëÁöÑÊ¢¶ÊÉ≥‰∫ÜÔºåÊàëÂ§™ÂÖ¥Â•ã‰∫ÜÔºÅ' }
]);

// Â∫îÁî®Á§∫‰æãÂè•Â≠ê
function applySample(sampleText: string) {
  text.value = sampleText;
}

// Ë∞ÉËØïÂáΩÊï∞ÔºöÊ£ÄÊü•Áä∂ÊÄÅ
function debugCurrentState() {
  const state = {
    text: text.value,
    textLength: text.value.length,
    isProcessing: animationProcessing.value,
    selectedModel: selectedModel.value,
    modelViewerExists: !!modelViewer.value,
    selectedVoice: selectedVoice.value,
    backgroundImage: !!backgroundImage.value,
    backgroundImageName: backgroundImageName.value,
    audioUrl: !!audioUrl.value,
    audioUrlValue: audioUrl.value,
    ssml: ssml.value,
    buttonDisabled: animationProcessing.value || !text.value.trim(),
    // Ê£ÄÊü•ÂáΩÊï∞ÊòØÂê¶Â≠òÂú®
    onAnimateExists: typeof onAnimate === 'function',
    synthesizeSpeechExists: typeof synthesizeSpeech === 'function',
    generateSSMLExists: typeof generateSSML === 'function',
    // Ê£ÄÊü•Èü≥È¢ëÂÖÉÁ¥†
    audioPlayerExists: !!audioPlayer.value,
    audioPlayerSrc: audioPlayer.value?.src || 'no src',
    audioPlayerCanPlay: (audioPlayer.value?.readyState ?? 0) >= 2
  };
  
  console.log('üîç Current state debug:', state);
  
  // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªª‰ΩïÂºÇÂ∏∏Áä∂ÊÄÅ
  if (!state.onAnimateExists) {
    console.error('‚ùå onAnimate function is missing!');
  }
  if (!state.synthesizeSpeechExists) {
    console.error('‚ùå synthesizeSpeech function is missing!');
  }
  if (state.isProcessing) {
    console.warn('‚ö†Ô∏è Already processing, please wait...');
  }
  if (!state.audioPlayerExists) {
    console.warn('‚ö†Ô∏è Audio player ref is null!');
  }
  if (state.audioUrl && !state.audioPlayerSrc) {
    console.warn('‚ö†Ô∏è Audio URL exists but player has no src!');
  }
  
  return state;
}
// isProcessing Âíå audioUrl Â∑≤ÁßªËá≥ useAnimation ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// Êó∂Èó¥ËΩ¥Áõ∏ÂÖ≥
const timeline = useTimeline(
  actionAnimations,
  emotionAnimations,
  modelViewer,
  currentAction,
  currentEmotion
);
const {
  actionKeyframes,
  emotionKeyframes,
  selectedKeyframe,
  isDragging,
  dragStartX,
  dragStartTime,
  timeMarkers,
  addActionKeyframe,
  addEmotionKeyframe,
  selectKeyframe,
  deleteKeyframe,
  updateKeyframe,
  clearTimeline,
  startDrag,
  onDrag,
  stopDrag,
  onTrackClick,
  getActionDisplayName,
  getEmotionDisplayName
} = timeline;

// ËßÜÈ¢ëÂΩïÂà∂Áõ∏ÂÖ≥
const recording = useRecording();
const {
  isRecording,
  mediaRecorder,
  recordedChunks,
  recordedVideoUrl,
  startRecording,
  stopRecording,
  resetRecordingState,
  checkRecordingState,
  downloadVideo
} = recording;

// Âä®ÁîªÂÆöÊó∂Âô®
const audioPlayer = ref<HTMLAudioElement | null>(null);

const ssml = ref(''); // Â≠òÊîæÁîüÊàêÁöÑ SSML
const isGeneratingSSML = ref(false); // ÊåâÈíÆ loading Áä∂ÊÄÅ

// Â¶ÇÊûúÈÖçÁΩÆ‰∫ÜÂâçÁ´Ø OpenAI KEYÔºåÂàô‰ºòÂÖàÂú®ÊµèËßàÂô®Áõ¥Êé•Ë∞ÉÁî® OpenAIÔºåÈÅøÂÖçË∑®Âüü / 404
const useFrontendOpenAI = Boolean(import.meta.env.VITE_OPENAI_API_KEY);
const generateSSML = useFrontendOpenAI ? generateSSMLFront : generateSSMLBackend;

// Azure ËØ≠Èü≥ÂêàÊàê‰æùÊóßÊåâÊûÑÂª∫Ê®°ÂºèÂå∫ÂàÜÔºöÁîü‰∫ßÈªòËÆ§Ëµ∞ÂêéÁ´Ø‰ª£ÁêÜ
const useFrontendAzure = Boolean(import.meta.env.VITE_AZURE_SPEECH_KEY);
const synthesizeSpeech = useFrontendOpenAI ? synthesizeSpeechFront : synthesizeSpeechBackend;

// ‰ΩøÁî®Âä®ÁîªÁªÑÂêàÂºèÂáΩÊï∞
const animation = useAnimation(
  text,
  ssml,
  selectedVoice,
  modelViewer,
  currentAction,
  currentEmotion,
  synthesizeSpeech,
  t,
  actionKeyframes,
  emotionKeyframes,
  audioPlayer
);
const {
  isProcessing: animationProcessing,
  audioUrl,
  animationTimer,
  visemeTimeline,
  onAnimate,
  startTimelineAnimation,
  handleViseme,
  syncVisemeWithAudio,
  speak
} = animation;

// ÂêåÊ≠•Â§ÑÁêÜÁä∂ÊÄÅ
watch(animationProcessing, (newValue) => {
  isProcessing.value = newValue;
});

onUnmounted(() => {
  // no play listener cleanup needed
  
  // Ê∏ÖÁêÜÈîÆÁõò‰∫ã‰ª∂ÁõëÂê¨Âô®
  document.removeEventListener('keydown', handleKeyDown);
});

// ‰∏ªË¶ÅÂä®ÁîªÁîüÊàêÂáΩÊï∞Â∑≤ÁßªËá≥ useAnimation ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// ÂºÄÂßãÂΩïÂà∂ÂáΩÊï∞Â∑≤ÁßªËá≥ useRecording ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// ÂΩïÂà∂Áõ∏ÂÖ≥ÂáΩÊï∞Â∑≤ÁßªËá≥ useRecording ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// ÂêØÂä®Êó∂Èó¥ËΩ¥Âä®ÁîªÂáΩÊï∞Â∑≤ÁßªËá≥ useAnimation ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠





// ÁõëÂê¨ÊñáÊú¨ÂèòÂåñÔºåÊõ¥Êñ∞Â≠óÁ¨¶ËÆ°Êï∞
watch(text, (newText: string) => {
  if (newText.length > 180) {
    text.value = newText.slice(0, 180);
  }
});

// ÂΩïÂà∂Áõ∏ÂÖ≥ÂáΩÊï∞Â∑≤ÁßªËá≥ useRecording ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// Ê∏ÖÁêÜÂáΩÊï∞
onUnmounted(() => {
  resetRecordingState();
});

// Êó∂Èó¥ËΩ¥Áõ∏ÂÖ≥ÂáΩÊï∞Â∑≤ÁßªËá≥ useTimeline ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// ÂÖ≥ÈîÆÂ∏ßÁõ∏ÂÖ≥ÂáΩÊï∞Â∑≤ÁßªËá≥ useTimeline ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// ÂÖ≥ÈîÆÂ∏ßÊõ¥Êñ∞ÂíåSSMLÁõ∏ÂÖ≥ÂáΩÊï∞Â∑≤ÁßªËá≥Áõ∏Â∫îÁöÑÁªÑÂêàÂºèÂáΩÊï∞‰∏≠

// ËÉåÊôØÊéßÂà∂Áõ∏ÂÖ≥ÂáΩÊï∞Â∑≤ÁßªËá≥ useBackground ÁªÑÂêàÂºèÂáΩÊï∞‰∏≠
</script>

<style lang="scss" scoped>
@import '@/styles/animate.scss';
</style>
